{
  "ATTRS": {
    "": {
      "st_atime": 1515972972.3604174,
      "st_ctime": 1515972972.3604174,
      "st_mode": 16386,
      "st_mtime": 1515972972.3604174,
      "st_nlink": 2
    },
    "goat.json": {
      "st_atime": 1515973202.5735915,
      "st_ctime": 1515973202.5735915,
      "st_mode": 33204,
      "st_mtime": 1515973202.5735915,
      "st_nlink": 1,
      "st_size": 337
    },
    "main.py": {
      "st_atime": 1515973216.8160203,
      "st_ctime": 1515973216.8160203,
      "st_mode": 33204,
      "st_mtime": 1515973216.8160203,
      "st_nlink": 1,
      "st_size": 10029
    }
  },
  "DATA": {
    "goat.json": "{\n  \"ATTRS\": {\n    \"\": {\n      \"st_atime\": 1515972972.3604174,\n      \"st_ctime\": 1515972972.3604174,\n      \"st_mode\": 16386,\n      \"st_mtime\": 1515972972.3604174,\n      \"st_nlink\": 2\n    }\n  },\n  \"DATA\": {},\n  \"EXTRAATTRS\": {},\n  \"FSMETA\": {\n    \"DEFAULTUMASK\": 2\n  },\n  \"LOOKUPMAP\": {\n    \"\": {\n      \"ENTITYTYPE\": \"FOLDERS\"\n    }\n  }\n}",
    "main.py": "from fuse import FUSE, FuseOSError, Operations\nfrom subprocess import call\nfrom json import load as json_load, dumps\nfrom stat import S_IFDIR, S_IFLNK, S_IFREG\nfrom collections import defaultdict\nfrom time import time\nimport os\nimport base64\nfrom errno import ENOENT, EINVAL, EEXIST\n\nFS_META = 'FSMETA'\nFSDATA = '__FSDATA__'\nEXTRA_ATTRS = 'EXTRAATTRS'\nDATA = 'DATA'\nLOOKUP_MAP = 'LOOKUPMAP'\nATTRS = 'ATTRS'\nFILES = 'FILES'\nFOLDERS = 'FOLDERS'\nFILE_SYSTEM = 'FILESYSTEM'\nENTITY_TYPE = 'ENTITYTYPE'\nDEFAULT_UMASK = 'DEFAULTUMASK'\nROOT = ''\nSEP = '/'\n\nST_MODE = 'st_mode'\nST_MTIME = 'st_mtime'\nST_CTIME = 'st_ctime'\nST_ATIME = 'st_atime'\nST_NLINK = 'st_nlink'\nST_UID = 'st_uid'\nST_GID = 'st_gid'\nST_SIZE = 'st_size'\n\n\ndef dump_to_json(obj):\n    obj_out = dict()\n    for top_key, top_val in obj.items():\n        if top_key not in {DATA, EXTRA_ATTRS}:\n            if isinstance(top_val, dict):\n                ascii_out = {top_key: {k: v for k, v in top_val.items() if k is not FSDATA}}\n            else:\n                ascii_out = {top_key: top_val}\n            obj_out.update(ascii_out)\n        else:\n            ascii_out = dict()\n            for inner_key, inner_val in top_val.items():\n                if inner_key is not FSDATA:\n                    try:\n                        inner_dict = {inner_key: inner_val.decode('UTF-8')}\n                    except:\n                        inner_dict = {inner_key: [base64.b64encode(inner_val).decode('UTF-8')]}\n                    ascii_out.update(inner_dict)\n            obj_out.update({top_key: ascii_out})\n    return dumps(obj_out, sort_keys=True, indent=2)\n\n\ndef dump_to_json_file(file_path, obj):\n    with open(file_path, 'w') as file_handle:\n        file_handle.write(dump_to_json(obj))\n\n\ndef load_from_json_file(file_path):\n    return_dict = dict()\n    with open(file_path) as file_handle:\n        for top_key, top_val in json_load(file_handle).items():\n            if top_key is not FILES:\n                return_dict.update({top_key: top_val})\n            else:\n                bytes_in = dict()\n                for inner_key, inner_val in top_val.items():\n                    inner_bytes = dict()\n                    if isinstance(inner_val, list):\n                        inner_bytes.update({inner_key: inner_val[0].encode('UTF-8')})\n                    else:\n                        inner_bytes.update({inner_key: base64.b64decode(inner_val.encode('UTF-8'))})\n                    bytes_in.update(inner_bytes)\n                return_dict.update({top_key: bytes_in})\n    return return_dict\n\n\ndef get_parent_dir(path):\n    return os.path.dirname(os.path.dirname(path))\n\n\ndef is_valid_dirname(path):\n    return path[-1] == SEP\n\n\ndef process_output(path):\n    output = path if not path else path[0:-1] if path[-1] == SEP else path\n    return output if not output else output[1::] if output[0] == SEP else output\n\n\nclass JSONFS(Operations):\n    DEFAULT_UMASK = None  # type: int\n    root_blob = None  # type: str\n    fs_meta = None  # type: dict\n    data = None  # type: dict\n    attrs = None  # type: dict\n    extra_attrs = None  # type: dict\n    lookup_map = None  # type: dict\n    file_system = None  # type: dict\n    fd = None  # type: int\n\n    def get_entity_type(self, path):\n        return self.lookup_map.setdefault(process_output(path), dict()).setdefault(ENTITY_TYPE)\n\n    def set_entity_type(self, path, entity_type):\n        self.lookup_map[process_output(path)][ENTITY_TYPE] = entity_type\n\n    def mkfs(self):\n        created_time = time()\n        root_node = {ST_MODE: (S_IFDIR | self.DEFAULT_UMASK),\n                     ST_CTIME: created_time,\n                     ST_MTIME: created_time,\n                     ST_ATIME: created_time,\n                     ST_NLINK: 2}\n        file_system = {\n            FS_META: {DEFAULT_UMASK: self.DEFAULT_UMASK},\n            DATA: defaultdict(bytes),\n            ATTRS: dict(),\n            EXTRA_ATTRS: defaultdict(bytes),\n            LOOKUP_MAP: defaultdict(dict)}\n        file_system[ATTRS][ROOT] = root_node\n        file_system[LOOKUP_MAP][ROOT] = {ENTITY_TYPE: FOLDERS}\n        return file_system\n\n    def __init__(self, root_blob=None, create_file_system=False, default_umask=os.umask(22)):\n        self.fd = 0\n        self.root_blob = os.path.abspath(os.path.dirname(root_blob))\n        if not create_file_system:\n            self.file_system = load_from_json_file(root_blob)\n            print(self.file_system)\n            self.DEFAULT_UMASK = self.file_system[FS_META][DEFAULT_UMASK]\n        else:\n            self.DEFAULT_UMASK = default_umask\n            self.file_system = self.mkfs()\n        self.root_blob = root_blob\n        self.fs_meta = self.file_system[FS_META]\n        self.attrs = self.file_system[ATTRS]\n        self.extra_attrs = self.file_system.setdefault(EXTRA_ATTRS, dict())\n        self.data = self.file_system.setdefault(DATA, dict())\n        self.lookup_map = self.file_system[LOOKUP_MAP]\n        self.create(FSDATA, 33204)\n\n    def chmod(self, path, mode):\n        path = process_output(path)\n        self.attrs[path][ST_MODE] &= 0o770000\n        self.attrs[path][ST_MODE] |= mode\n        return 0\n\n    def chown(self, path, uid, gid):\n        path = process_output(path)\n        self.attrs[path][ST_UID] = uid\n        self.attrs[path][ST_GID] = gid\n        return 0\n\n    def create(self, path, mode, fi=None):\n        path = process_output(path)\n        if path in self.attrs and path is not FSDATA:\n            raise FuseOSError(EINVAL)\n        created_time = time()\n        self.attrs[path] = {\n            ST_MODE: (S_IFREG | mode),\n            ST_NLINK: 1,\n            ST_SIZE: 0,\n            ST_CTIME: created_time,\n            ST_MTIME: created_time,\n            ST_ATIME: created_time\n        }\n        self.data[path] = bytes()\n        self.lookup_map[path] = dict()\n        self.set_entity_type(path, FILES)\n        self.fd += 1\n        return self.fd\n\n    def getattr(self, path, fh=None):\n        path = process_output(path)\n        if path == FSDATA:\n            self.write(path, dump_to_json(self.file_system).encode('UTF-8'), 0, 0)\n        if path not in self.attrs:\n            raise FuseOSError(ENOENT)\n        return self.attrs[path]\n\n    def getxattr(self, path, fh=None, **kwargs):\n        path = process_output(path)\n        if path not in self.attrs:\n            raise FuseOSError(ENOENT)\n        return self.extra_attrs[path]\n\n    def mkdir(self, path, mode):\n        path = process_output(path)\n        if path in self.attrs:\n            raise FuseOSError(EEXIST)\n        created_time = time()\n        self.attrs[path] = {\n            ST_MODE: (S_IFDIR | mode),\n            ST_NLINK: 2,\n            ST_SIZE: 0,\n            ST_CTIME: created_time,\n            ST_MTIME: created_time,\n            ST_ATIME: created_time\n        }\n        self.attrs[process_output(get_parent_dir(path))][ST_NLINK] += 1\n        self.set_entity_type(path, FOLDERS)\n        return 0\n\n    def open(self, path, flags):\n        self.fd += 1\n        return self.fd\n\n    def read(self, path, size, offset, fh):\n        path = process_output(path)\n        return self.data[path][offset:offset + size]\n\n    def readdir(self, path, fh):\n        path = process_output(path)\n        return_list = ['.', '..']\n        for full_path in self.attrs.keys():\n            out_item = process_output(full_path)\n            if out_item and out_item != path and out_item[0:len(path)] == path:\n                return_list.append(out_item)\n        return return_list\n\n    def rename(self, old, new):\n        old = process_output(old)\n        new = process_output(new)\n        if old not in self.attrs:\n            raise FuseOSError(ENOENT)\n        if new in self.attrs:\n            raise FuseOSError(EEXIST)\n        self.attrs[new] = self.attrs.pop(old)\n        self.extra_attrs[new] = self.extra_attrs.pop(old)\n        self.extra_attrs[new] = self.extra_attrs.pop(old)\n        self.data[new] = self.extra_attrs.pop(old)\n        return 0\n\n    def rmdir(self, path):\n        # TODO: ADD CHECKS\n        path = process_output(path)\n        self.attrs.pop(path)\n        self.lookup_map.pop(path)\n        self.extra_attrs.pop(path)\n        self.data.pop(path)\n        self.attrs[get_parent_dir(path)][ST_NLINK] -= 1\n\n    def statfs(self, path):\n        path = process_output(path)\n        return self.attrs[path]\n\n    def symlink(self, target, source):\n        # TODO: ADD CHECKS\n        self.attrs[target] = {ST_MODE: S_IFLNK | 0o777,\n                              ST_NLINK: 1,\n                              ST_SIZE: len(source)}\n        ent_type = self.get_entity_type(source)\n        self.set_entity_type(target, ent_type)\n        return 0\n\n    def truncate(self, path, length, fh=None):\n        # TODO: ADD CHECKS\n        path = process_output(path)\n        if path not in self.attrs:\n            raise FuseOSError(ENOENT)\n        self.data[path] = self.data[path][:length]\n        self.attrs[path][ST_SIZE] = length\n        return 0\n\n    def unlink(self, path):\n        path = process_output(path)\n        if path not in self.attrs:\n            raise FuseOSError(ENOENT)\n        self.data.pop(path)\n        self.attrs.pop(path)\n        self.extra_attrs.pop(path)\n        self.lookup_map.pop(path)\n        return 0\n\n    def utimens(self, path, times=None):\n        path = process_output(path)\n        if path not in self.attrs:\n            raise FuseOSError(ENOENT)\n        created_time = time()\n        atime, mtime = times if times else (created_time, created_time)\n        self.attrs[path][ST_ATIME] = atime\n        self.attrs[path][ST_MTIME] = mtime\n        return 0\n\n    def write(self, path, data, offset, fh):\n        path = process_output(path)\n        self.data[path] = self.data[path][:offset] + data\n        self.attrs[path][ST_SIZE] = len(self.data[path])\n        return len(data)\n\n\ndef main():\n    root_blob = 'goat.json'\n    call(['fusermount', '-u', 'mountdir'])\n    FUSE(JSONFS(root_blob, create_file_system=False), 'mountdir', nothreads=True, foreground=True)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  "EXTRAATTRS": {},
  "FSMETA": {
    "DEFAULTUMASK": 2
  },
  "LOOKUPMAP": {
    "": {
      "ENTITYTYPE": "FOLDERS"
    },
    "goat.json": {
      "ENTITYTYPE": "FILES"
    },
    "main.py": {
      "ENTITYTYPE": "FILES"
    }
  }
}